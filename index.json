[{"categories":["golang"],"content":"go语言质量编程，写代码，不写bug，elegant...","date":"2022-05-15","objectID":"/2022/05/go-quality-program/","tags":["质量编程"],"title":"Golang高质量编程与性能调优实战","uri":"/2022/05/go-quality-program/"},{"categories":["golang"],"content":"Golang高质量编程与性能调优实战 | 青训笔记 这是我参与「第三届青训营 -后端场」笔记创作活动的的第3篇笔记。 本篇blog将对前面学习的Go by Example最后一部分进行归纳总结，主要内容有函数自定义排序、文件读写以及命令行相关参数等等。同时对如何进行高质量编程，Go程序优化手段和pprof性能分析工具的使用进行学习总结。完整代码见Github。 ","date":"2022-05-15","objectID":"/2022/05/go-quality-program/:1:0","tags":["质量编程"],"title":"Golang高质量编程与性能调优实战","uri":"/2022/05/go-quality-program/"},{"categories":["golang"],"content":"Go by Example sort包实现了内建及用户自定义数据类型的排序功能。它是原地排序，不返回一个新切片。 strs := []string{\"c\", \"a\", \"b\"} sort.Strings(strs) ints := []int{7, 2, 4} sort.Ints(ints) 通过实现sort.Interface接口的Len、Less、Swap方法， 就可以使用sort包的通用Sort方法，实现自定义函数排序。实现一个按字符串长度排序的例子： type byLength []string func (s byLength) Len() int { return len(s) } func (s byLength) Swap(i, j int) { s[i], s[j] = s[j], s[i] } func (s byLength) Less(i, j int) bool { return len(s[i]) \u003c len(s[j]) } func main() { fruits := []string{\"peach\", \"banana\", \"kiwi\"} sort.Sort(byLength(fruits)) fmt.Println(fruits) } // output:[kiwi peach banana] 我们用panic来表示程序正常运行中不应该出现的错误， 或者我们不准备优雅处理的错误。当函数返回我们不知道如何处理（或不想处理）的错误值时，中止操作，这是panic常用的方法。 defer一般是执行清理工作，比如关闭文件等，并且在错误检查之后，因为它代表对象已经存在，才会进行清理工作，否则会出现空指针错误。 recover可以阻止panic中止程序，并让它继续执行，recover的返回值是在调用panic时抛出的错误。 os.Open只读文件，os.OpenFile可以指定是否可读可写。 os.Args提供原始命令行参数访问功能。 ","date":"2022-05-15","objectID":"/2022/05/go-quality-program/:1:1","tags":["质量编程"],"title":"Golang高质量编程与性能调优实战","uri":"/2022/05/go-quality-program/"},{"categories":["golang"],"content":"高质量编程 高质量的代码有4个特性： 正确性，完备考虑各种边界条件； 可靠性，处理各种异常、错误，保证服务的稳定； 易维护，逻辑简单，后续调整或添加功能能够快速支持； 易阅读，代码能够被他人清晰阅读，容易理解。 高质量编程3个通用原则： 简单，没有多余的复杂性，能够以清晰的逻辑编写代码； 复杂的程序逻辑，不易重构和优化，遇到问题也难以排查。 可读，代码是给人阅读的，可读才可维护； 生产力，编程更多是团队合作，团队整体的工作效率是十分重要的。 Go通过go fmt统一代码格式，降低新成员上手项目代码的成本。 编码规范 代码格式： 使用go fmt自动格式化代码； 注释： 解释代码作用。代码实现的原因是什么，代码是如何实现的，代码什么情况会出错； 对于公共符号始终要注释。比如公共的变量、常量、函数以及结构等； 代码是最好的注释，注释应该提供代码来表达出的上下文信息。 命名规范： 变量名要简洁，缩略词全大写，比如ServeHTTP; 变量距离被使用的地方越远，越需要携带更多的上下文信息，使其含义易读。 下边举几个例子，感受一下变量命名的好坏。 i和index的作用域仅限于for循环，index的额外冗余并没有增加对于程序的理解。 // Bad for index := 0; index \u003c len(s); index++ { // do something } // Good for i := 0; i \u003c len(s); i++ { // do something } deadline有特殊含义，替换成t降低了变量名的信息量。 // Good func (c *Client) send(req *Request, deadline time.Time) // Bad func (c *Client) send(req *Request, t time.Time) 函数名不携带包名的上下文，因为包名和函数名总是成对出现； // http包中函数 // Good func Serve(l net.Listener, handler Handler) error // Bad func ServeHTTP(l net.Listener, handler Handler) error package名只由小写字母组成； 简短并包含一定的上下文信息，比如schema、task等； 不要与标准库同名，比如不要使用sync、strings等； 不要使用常用变量名作为包名，比如使用bufio而不是buf； 包名使用单数，比如使用encoding而不是encodings； 谨慎使用缩写，在不破坏上下文的情况下fmt比format更简短。 控制流程： 避免嵌套，保持正常流程清晰； // Bad if foo { return x } else { return nil } // Good if foo { return x } return nil 尽量保持正常代码路径为最小缩进，遵守线性原理； 也就是优先处理错误情况/特殊情况，尽早返回或继续循环来减少嵌套。 // Bad func OneFunc() error { err := doSomething() if err == nil { err := doAnotherThing() if err == nil { return nil // normal case } return err } return err } // Good func OneFunc() error { if err := doSomething(); err != nil { return err } if err := doAnotherThing(); err != nil { return err } return nil // normal case } 错误和异常处理： 简单错误是指仅出现一次的错误，在其他地方不需要捕获该错误； 优先使用errors.New来创建匿名变量直接表示简单错误； 如果有格式化的需求，使用fmt.Errorf。 func defaultCheckRedirect(req *Request, via []*Request) error { if len(via) \u003e= 10 { return errors.New(\"stopped after 10 redirects\") } return nil } 错误的Wrap提供了一个error嵌套另一个error，生成了一个error跟踪链； 在fmt.Errorf中使用%w将一个错误关联至错误链中。 list, _, err := c.GetBytes(cache.Subkey(a.actionID, \"srcfiles\")) if err != nil { return fmt.Errorf(\"reading srcfiles list:%w\", err) } 使用errors.Is判定一个错误是否为特定错误； 不同于==，使用该方法可以判定错误链上的所有错误是否含有特定的错误。 data, err = lockedfile.Read(targ) if errors.Is(err, fs.ErrNotExist) { return []byte{}, nil } return data, err 在错误链上获取特定种类的错误，使用errors.As； 它和Is的区别在于，会提取出调用链中指定类型的错误，并将错误赋值给定义好的变量，以便后续处理，下例是将问题的patch打印出来： if _, err := os.Open(\"non-existing\"); err != nil { var pathError *fs.PathError if errors.As(err, \u0026pathError) { fmt.Println(\"Failed at path:\", pathError.Path) } else { fmt.Println(err) } } 当程序启动阶段发生不可逆转的错误时，可以在init或main使用panic，其他业务代码不建议使用； recover只能在被defer的函数中使用，嵌套无法生效，只在当前goroutine生效； func (s *ss) Token(skipSpace bool, f func(rune) bool) (tok []byte, err error) { // defer LIFO defer func() { if e := recover(); e != nil { if se, ok := e.(scanError); ok { err = se.err } else { panic(e) } } }() // do something } 性能优化建议 性能优化的前提是满足程序的正确可靠，简洁清晰。性能优化是综合评估，时间效率和空间效率常常是对立的两方，对Go语言特性，总结其性能优化建议。 Benchmark： 使用Go自带的性能评估工具，以实际数据评价代码性能，示例： // fib.go func Fib(n int) int { if n \u003c 2 { return n } return Fib(n-1)+Fib(n-2) } // fib_test.go func BenchmarkFib10(b *testing.B) { for n := 0; n \u003c b.N; n++ { Fib(10) } } 命令：go test -bench=. -benchmem BenchmarkFib10-8：测试函数名-8，8是GOMAXPROCS的值，默认为CPU核数； 4473883：b.N的值，表示一共执行这么多次； 247.4 ns/op：表示每次执行花费的时间； 0 B/op：表示每次执行申请多大的内存； 0 allocs/op：表示每次执行申请几次内存。 Slice： 预分配： 在使用make初始化slice时预分配内存，提供容量信息，示例对比： func NoPreAlloc(size int) { data := make([]int, 0) for k := 0; k \u003c size; k++ { data = append(data, k) } } func PreAlloc(size int) { data := make([]int, 0, size) for k := 0; k \u003c size; k++ { data = append(data, k) } } 命令：go test -bench=. -benchmem slice预分配内存不仅节约了时间，内存申请次数也只有一次。 出现这种现象的原因是，slice是数组片段的描述，包括：数组指针，数组长度，数组容量；切片操作并不复制切片指向的元素，创建一个新切片会复用原来切片的底层数组。 type slice struct { array unsafe.Pointer len int cap int } append有两种情况： append之后，slice长度小于等于cap，直接利用原底层数组剩余空间； append之后，slice长度大于cap，会分配一块更大的区域容纳新的底层数组。 为了避免发生内存拷贝，如果知道最终slice大小，预分配cap能够减少内存分配，获得更好的性能。 大内存未释放： 如果原slice是由大量元素组成，我们在此基础再切片，只使用了一小部分，但底层数组仍然在内存中占用大量空间，得不到释放。可以使用copy代替re-s","date":"2022-05-15","objectID":"/2022/05/go-quality-program/:1:2","tags":["质量编程"],"title":"Golang高质量编程与性能调优实战","uri":"/2022/05/go-quality-program/"},{"categories":["golang"],"content":"性能调优实战 性能调优原则： 依靠数据而不是猜测； 定位最大瓶颈而不是细枝末节； 不要过早优化； 不要过度优化。 pprof实战 pprof是用于可视化和分析性能，分析数据的工具，能够告知程序在什么地方耗费了多少CPU，多少内存等实际的数据指标。 pprof功能 pprof可以采样程序运行时的CPU、堆内存、goroutine、锁竞争、阻塞调用和系统线程等的使用数据，同时通过列表、调用图、火焰图、源码以及反汇编等视图展示采集到的性能指标。 pprof排查 搭建项目，git clone源码，项目提前埋入炸弹代码，能够产生可观测的性能问题。会占用1CPU核心和超过1GB的内存。 func main() { ... runtime.GOMAXPROCS(1) // 限制CPU使用数 runtime.SetMutexProfileFraction(1) // 开启锁调用跟踪 runtime.SetBlockProfileRate(1) // 开启阻塞调用跟踪 go func() { // 启动http server if err := http.ListenAndServe(\":6060\", nil); err != nil { log.Fatal(err) } os.Exit(0) }() ... } main.go初始化http服务和pprof接口，import _ \"net/http/pprof\"，它会注册pprof的handler到http server。 2. 浏览器查看指标，我们可以在浏览器打开http://127.0.01:6060/debug/pprof查看基本的性能统计。 allocs: 内存分配情况； blocks: 阻塞操作情况； cmdline: 当前程序命令行调用情况； goroutine: 当前所有goroutine的堆栈信息； heap: 堆上内存使用情况（同allocs）； mutex: 锁竞争操作情况； profile: CPU占用情况； threadcreate: 当前所有创建的系统线程的堆栈信息； trace: 程序运行跟踪信息。 浏览器数据可读性比较差，可借助pprof阅读这些数据指标。 3. CPU问题排查； 明显CPU占用异常，pprof的采样结果是将一段时间内的信息汇总输出到文件中，因此要拿到这个profile文件，可使用pprof工具连接接口下载需要的数据。我们使用go tool pprof+采样链接启动采样。 go tool pprof \"http://127.0.0.1:6060/debug/pprof/profile?seconds=10\"，profile代表采样对象是CPU使用情况，如果在浏览器打开该链接，会启动一个60s的采样，并在结束后下载文件，我们这里加上seconds=10，让其采样10s。 输入top可以查看CPU占用最高的函数： flat 表示当前函数本身的执行耗时； flat% 表示flat占CPU总量的比例； sum% 表示上面所有行的flat%总和； cum 表示当前函数加上其调用函数的总占用； cum% cum占总量的比例。 表格前面描述了采样的总体信息，默认展示占用资源最高的10个函数，如果需要看最高的N个，输入topN，比如top3查看前3个占用最高的调用。 可以看出表格第一行是问题所在，这个函数本身执行耗时flat，调用函数总耗时cum都3s左右，但flat%和cum%占用都超过90%。 从表中还能看到一些其他情况，比如flat和cum相等，或者有时为0。 什么情况下，falt==cum？函数中没有对其他函数的调用。 什么情况下，flat==0？函数中只有其他函数的调用。 输入list Eat查找这个函数，list会根据给定的正则表达式查找代码，并按行展示出每一行的占用。 可以看见这条3.15s的占用是问题所在，定位成功。 输入web，生成一张调用关系图，调用关系可视化。可能需要安装graphviz组件，通过命令brew install graphviz安装即可。其中方框最红最大的就是占用CPU最多的函数。CPU炸弹定位完成，输入q退出终端。 为了后续的展示，将问题代码注释，拆除这个炸弹，重新运行程序。 明显CPU占用已经降下来，但内存占用问题还存在。 Heap堆内存问题排查； 这里我们通过-http=:8080开启pprof自带的Web UI，使用命令go tool pprof -http=:8080 \"http://127.0.0.1:6060/debug/pprof/heap\"完成对heap的采样。 明显看出，Steal函数是问题所在，占用了1.2GB内存。通过view菜单可以看不同视图比如top视图，source视图，可搜索Steal进行函数定位： 问题函数已定位，将其注释，发现内存正常，至此两个炸弹已拆除。 采样也没有异常节点，但内存问题就全部排除了吗？注意右上角unknow_inuse_space，打开sample菜单，发现堆内存有4个指标： alloc_objects: 程序累计申请的对象数； alloc_space: 程序累计的内存大小； inuse_objects: 程序当前持有的对象数； inuse_space: 程序当前占用的内存大小。 默认展示inuse_space，只展示当前持有的内存，但如果有的内存已经释放，inuse采样就不会展示了，切换到alloc_space指标，继续alloc内存问题分析（左：Source视图Run函数；右：Top视图）： 明显Run函数是问题所在，它每次申请16MB大小内存，累计申请超过2.69GB，注释问题代码，继续后续排查，至此内存炸弹已经全部拆除。 goroutine泄漏，导致内存泄漏； 执行命令go tool pprof -http=:8080 \"http://127.0.0.1:6060/debug/pprof/goroutine\"，可以看见一张很长的调用关系图，节点过多，难以阅读，可以打开view菜单，通过Flame Graph 火焰图阅读。 由上到下表示调用顺序，每一块代表一个函数，越长代表占用CPU的时间更长，火焰图是动态的，支持点击块进行分析，可以看见Drink函数调用创建了超过95%的goroutine。 在source视图可见问题函数，每次执行10条无意义的goroutine，每条等待30s后退出，导致goroutine泄漏。 设想一下，如果发起的goroutine没有退出，同时不断有goroutine被启动，对应的内存占用持续增长，CPU调度压力不断增大，最终进程会被系统kill。注释问题代码，goroutine泄漏问题解决。 mutex，锁竞争； 执行命令go tool pprof -http=:8080 \"http://127.0.0.1:6060/debug/pprof/mutex\"，在Graph视图能够定位到问题函数Howl，在Source视图能够看见是哪一行代码发生了锁竞争。在这个函数中，goroutine等待了1s才解锁，阻塞了，注释即可。 block阻塞； 执行命令go tool pprof -http=:8080 \"http://127.0.0.1:6060/debug/pprof/block\"，除了锁竞争会导致阻塞，其他逻辑，比如读取一个channel也会导致阻塞，在页面中可以看到阻塞操作还有两个。 从Graph视图到Source视图，看到Pee函数读取了一个time.After()生成的channel，导致了这个goroutine阻塞了1s而不是等待了1s，注释代码解决阻塞。 通过上述操作只定位到了1个block，终端输入go tool pprof \"http://127.0.0.1:6060/debug/pprof/block\"和top可以看见另外一个阻塞操作的节点。有3个节点因为cumulative小于4.24s被drop，它的总用时小于总时长的千分之五，所以被省略了，没有展示。这样的过滤策略能够更加有效地突出问题所在，省略相对没有问题的信息，便于问题定位，解决主要瓶颈问题。 那如何查看另外一个阻塞操作呢？可以通过暴露的接口地址直接访问，打开block，发现第二个阻塞操作发生在http handler。 至此代码中所有炸弹已经找出并解决，我们完成了以下实践操作： 5种使用pprof采集的常用性能指标：CPU、堆内存、Goroutine、锁竞争和阻塞； 2种展示方式：交互式终端和Web UI； 4种视图：Top、Graph、Source和Flame Graph。 采样过程和原理 知其然，知其所以然，看看pprof内部实现是怎样的。 首先是CPU，有3个主要采样指标： 采样对象：所有调用栈和它们的占用时间； 采样率：100次/秒，固定值； 进程每秒暂停100次，记录当前的调用栈信息，汇总后，根据调用栈在采样中出现次数推断函数的运行时间； 采样时间：从手动启动到手动结束。 这个100次/秒的定时暂停机制在unix或类unix系统上是通过依赖信号机制实现的。每次暂停都会接收到一个信号，通过系统计时器来保证这个信号固定频率发送。 采样具体流程： 一共3个对象： 操作系统：每10ms向进程发送一次SIGPROF信号； 进程：每次接受到SIGPROF会记录调用堆栈； 写缓冲：每100ms读取已经记录的调用栈并写入输出流。 第二个是堆内存，由于pprof的局限性，采样的是堆内存而不是内存，内存采样在实现上依赖内存分配器的记录，所以只能记录在堆上分配，会参与GC的内存，一些其他的内存分配，比如","date":"2022-05-15","objectID":"/2022/05/go-quality-program/:1:3","tags":["质量编程"],"title":"Golang高质量编程与性能调优实战","uri":"/2022/05/go-quality-program/"},{"categories":["golang"],"content":"总结 至此，整个高质量编程与性能调优实战课程总结归纳完毕，在这门课学到了很多。对于实际工作中服务性能优化有所了解，算是入个门不过分吧；对于如何分析性能问题，服务优化的原则和优化流程都进行了学习。同时也对性能分析工具pprof的基本原理，相关使用操作和如何排查性能问题，进行了简单的入门实践。 收获很多，十分感谢张雷老师的授课讲解！ ","date":"2022-05-15","objectID":"/2022/05/go-quality-program/:1:4","tags":["质量编程"],"title":"Golang高质量编程与性能调优实战","uri":"/2022/05/go-quality-program/"},{"categories":["golang"],"content":"引用参考 Go by Example 中文版 Golang标准库文档 极客兔兔：大量内存得不到释放 Go pprof实战 ","date":"2022-05-15","objectID":"/2022/05/go-quality-program/:1:5","tags":["质量编程"],"title":"Golang高质量编程与性能调优实战","uri":"/2022/05/go-quality-program/"},{"categories":["golang"],"content":"go语言基础实践，巩固基础语法...","date":"2022-05-12","objectID":"/2022/05/go-practice/","tags":["go实践"],"title":"Golang工程实践","uri":"/2022/05/go-practice/"},{"categories":["golang"],"content":"Golang工程实践 | 青训笔记 这是我参与「第三届青训营 -后端场」笔记创作活动的的第2篇笔记。 继续通过Go by Example对基础语法进行巩固，本篇总结了与并发编程相关的基础语法，如通道、协程和WaitGroup等。同时对Golang依赖管理Go Module的使用进行总结，对Go程序如何进行单元测试以及相关注意事项进行总结。最后是以“青训营话题页”为需求，进行项目实战，主要实现了话题和回帖的查询功能和发帖功能。完整代码见Github。 ","date":"2022-05-12","objectID":"/2022/05/go-practice/:1:0","tags":["go实践"],"title":"Golang工程实践","uri":"/2022/05/go-practice/"},{"categories":["golang"],"content":"并发编程语法 通道 goroutine是轻量级的执行线程，通过关键字go就能同步或异步启动一个协程。Go runtime是以并发的方式运行协程。 func f(from string) { for i := 0; i \u003c 3; i++ { fmt.Println(from, \":\", i) } } f(\"direct\") // 直接调用函数 go f(\"goroutine\") // 启动协程调用函数 channel是连接多个goroutine的管道，可以从一个goroutine发送数据给channel，另一个goroutine从channel接收数据。默认发送和接收都是阻塞的，也就是说默认的channel是同步操作。 messages := make(chan string) go func() { messages \u003c- \"ping\" }() msg := \u003c- messages fmt.Println(msg) 默认channel是无缓冲的，所以能够实现同步。有缓冲的channel能够实现异步。 messages := make(chan string, 2) messages \u003c- \"buffered\" messages \u003c- \"channel\" fmt.Println(\u003c-messages) fmt.Println(\u003c-messages) 通过无缓冲channel，以阻塞接收的方式实现同步。 func worker(done chan bool) { fmt.Print(\"working...\") time.Sleep(time.Second) fmt.Println(\"done\") done \u003c- true } done := make(chan bool) go worker(done) // 阻塞接收 \u003c- done channel作为函数参数，可以指定方向，是否只读或只写，可以提升程序的安全性。 pings := make(chan\u003c- string) // 只写 pongs := make(\u003c-chan string) // 只读 select可以同时等待多个channel，选择channel执行。 使用带default的select实现非阻塞通道的发送、接收，也可以实现非阻塞的多路select。 messages := make(chan string) // 非阻塞接收 select { case msg := \u003c- messages: fmt.Println(\"received message\", msg) default: fmt.Println(\"no message received\") } // 非阻塞发送 msg := \"hi\" select { case messages \u003c- msg: fmt.Println(\"sent message\", msg) default: fmt.Println(\"no message sent\") } 通过channel和select可以进行超时处理。 当关闭一个channel以后，就不能再发送数据给channel，因此可以向channel的接收方传达工作已经完成的信息。 线程和协程的区别： 一个线程可以有多个协程，协程是轻量级线程； 线程栈MB级别，协程栈KB级别。 定时 Go可以通过Timer设置在未来某个时间点运行Go代码。 // 定时器等待2s timer1 := time.NewTimer(2*time.Second) // 一直阻塞，直到C明确发送定时器失效的值 \u003c-timer1.C fmt.Println(\"Timer 1 fired\") 当你想要以固定的时间间隔重复执行，可以使用Ticker。 // 数据每隔500ms到达 ticker := time.NewTicker(500*time.Millisecond) done := make(chan bool) go func() { for { select { case \u003c- done: return case t := \u003c-ticker.C: fmt.Println(\"Tick at\", t) } } }() // 等待1600ms后，停止ticker time.Sleep(1600*time.Millisecond) ticker.Stop() done \u003c- true fmt.Println(\"Ticker stopped\") Golang可以基于goroutine、channel和timer实现速率限制。速率限制是控制服务资源利用和质量的重要机制。 WaitGroup 使用WaitGroup等待多个goroutine完成。 func worker(id int) { fmt.Printf(\"Worker %d strarting\\n\", id) time.Sleep(time.Second) fmt.Printf(\"Worker %d done\\n\", id) } func main() { var wg sync.WaitGroup // 启动goroutine，并递增WaitGroup的计数器 for i := 1; i \u003c= 5; i++ { wg.Add(1) i := i // 将worker调用封装到一个闭包中，可以确保通知WaitGroup，此工作线程已完成 // worker线程本身也就不需要知道执行涉及的并发原语 go func() { defer wg.Done() worker(i) }() } // 阻塞，直到WaitGroup计数器恢复为0 wg.Wait() } Go的状态管理机制主要是依靠channel的通信来完成的，通过sync/atomic可以实现多个goroutine间的原子计数。 func main() { // 无符号整型变量表示计数器 var ops uint64 // 等待所有goroutine完成工作 var wg sync.WaitGroup // 启动50个goroutine，每个goroutine会将计数器递增1000次 for i := 0; i \u003c 50; i++ { wg.Add(1) go func() { for c := 0; c \u003c 1000; c++ { // 使用AddUint64让计数器自增 atomic.AddUint64(\u0026ops, 1) } wg.Done() }() } // 等待所有goroutine结束 wg.Wait() // 安全访问ops, 50000 fmt.Println(\"ops:\", ops) } 使用互斥量在Go协程间安全访问数据。 type Container struct { mu sync.Mutex counters map[string]int } func (c *Container) inc(name string) { // 互斥访问counters，实现数据同步 c.mu.Lock() defer c.mu.Unlock() c.counters[name]++ } Go共享内存的思想是，通过通信使每个数据仅被单个协程拥有，也就是通过通信实现共享内存。 WaitGroup的Add对计数器加1，Done对计数器减一，Wait主线程阻塞直到计数器为0。 ","date":"2022-05-12","objectID":"/2022/05/go-practice/:1:1","tags":["go实践"],"title":"Golang工程实践","uri":"/2022/05/go-practice/"},{"categories":["golang"],"content":"依赖管理 Go语言包的依赖管理主要有两个问题： 如何控制不同环境（项目）依赖的版本； 如何控制依赖库的版本。 演进过程 GOPATH：是Go的环境变量，它无法满足不同项目依赖同一个库的不同版本； 项目A和项目B依赖于同一package的不同版本，依赖冲突。 Go Vendor：将依赖包副本存放在Vendor目录下，可以满足多个项目需要同一个package的不同版本的需求；但无法控制依赖库的版本，更新项目可能出现依赖冲突，导致编译出错； 项目A的依赖库package D的不同版本无法兼容，依赖冲突。 Go Module： Go官方推出的依赖管理系统，解决了上诉两个依赖管理问题。通过go.mod文件管理依赖包版本，通过go get/go mod命令工具管理依赖包。 Go Module 依赖管理三要素： 配置文件，描述依赖——go.mod; 中心仓库管理依赖库——Proxy; 本地工具——go get/go mod。 依赖配置 项目多库依赖中，依赖配置选择最低的兼容版本。 依赖分发 直接使用版本管理仓库下载依赖，主要存在3个问题： 无法保证构建稳定性：如果软件作者增加/修改/删除软件版本，会导致构建使用其他版本的依赖，或者找不到依赖版本； 无法保证依赖可用性：如果软件作者直接从代码平台删除软件，会保证依赖不可用； 增加第三方压力：给代码托管平台增加负载压力。 go proxy能够解决这些问题，它会缓存源站的软件内容，缓存的软件版本不会改变，在源站删除软件之后也能使用，实现了immutability和available的依赖分发。 Go Module通过GOPROXY环境变量控制go proxy的使用。示例配置： GOPROXY=\"https://proxy1.cn, https://proxy2.cn, direct\" 整体的依赖寻址路径，会优先从proxy1下载；如果proxy1不存在，就从proxy2下载；如果proxy2不存在，就从direct（源站）下载，并缓存到proxy1，proxy2站点中。 工具 go get go get example.org/pkg@XXX // XXX:update 默认 // XXX:none 删除依赖 // XXX:v1.1.2 tag版本，语义版本 // XXX:23dfdd5 特定的commit // XXX:master 分支的最新commit go mod go mod init projName // 初始化，创建go.mod文件 go mod tidy // 增加需要的依赖，删除不需要的依赖 go mod download // 下载模块到本地缓存 go mod graph // 打印依赖图 go mod verify // 校验依赖 ","date":"2022-05-12","objectID":"/2022/05/go-practice/:1:2","tags":["go实践"],"title":"Golang工程实践","uri":"/2022/05/go-practice/"},{"categories":["golang"],"content":"测试 分类 软件测试能够反映系统的质量问题，质量问题决定着系统的稳定性，如果线上系统出现bug，就会造成事故，而事故直接和收益挂钩。如何避免事故的发生，就要通过完备的测试。 测试分为： 回归测试：QA手动通过终端回归一些固定的主流程场景； 集成测试：对系统功能维度进行测试验证； 单元测试：测试开发阶段，开发者对单独的函数，模块做功能验证。 三者的层级从上至下，测试成本逐渐减少，而测试覆盖率逐渐上升，所以单元测试的覆盖率一定程度决定代码质量。 单元测试 单元测试主要包括：输入、测试单元、输出以及校对。测试单元有接口、函数和模块等，校对可以保证代码的功能与我们的预期是否相符。 单元测试一方面保证质量，在整体覆盖率足够的情况下，一定程度上既保证了新功能本身的正确性，又未破坏原有代码的正确性。另一方面可以提升效率，在代码有bug的情况下，通过编写单元测试，可以在一个较短周期内定位和修复问题。 规则： 所有测试文件以_test.go结尾； func TestXXX(*testing.T)，被测函数首字母需要大写； 初始化逻辑放到TestMain中。 代码覆盖率： 衡量代码是否经过足够的测试； 评价项目的测试水准； 评估项目是否达到高水准测试等级。 例子： // judgement.go func JudgePassLine(score int16) bool { if score \u003e= 60 { return true } return false } // judgement_test.go func TestJudgePassLineTre(t *testing.T) { output := JudgePassLine(70) expectOutput := true assert.Equal(t, expectOutput, output) } func TestJudgePassLineFalse(t *testing.T) { output := JudgePassLine(50) expectOutput := false assert.Equal(t, expectOutput, output) } // 命令：go test judgement_test.go judgement.go --cover // 结果：ok command-line-arguments 0.711s coverage: 100.0% of statements 测试tips： 实际项目中，一般要求的是50%~60%的覆盖率，对于资金型服务，覆盖率要求达到80%+； 测试分支要相互独立，全面覆盖； 测试单元粒度要足够小，要符合函数设计的单一职责。 依赖： 工程中复杂的项目，单元测试会依赖File、DB和Cache等外部依赖；单元测试需要保证稳定性和幂等性。 稳定性是指相互隔离，能在任何时间、任何环境运行测试； 幂等性是指每一次的测试运行都应该产生和之前一样的结果。 Mock机制可以实现稳定性和幂等性。 Mock测试 使用Monkey mock测试库：https://github.com/bouk/monkey。它可以对method或者实例的方法进行mock、反射和指针赋值。 Monkey Patch的作用域在Runtime，在运行时通过Go的unsafe包，能够将内存中函数的地址替换为运行时函数的地址。将待打桩函数或方法的实现跳转。具体代码见Github。 基准测试 基准测试是指测试一段程序的运行性能以及耗费CPU的程度。在实际项目开发中，经常会遇到代码性能瓶颈，为了定位问题经常要对代码做性能分析，就会用到基准测试。 服务器负载均衡例子，随机选择执行服务器： // load_balance_selector.go var ServerIndex [10]int func InitServerIndex() { for i := 0; i \u003c 10; i++ { ServerIndex[i] = i } } func Select() int { return rand.Intn(10) } func FastSelect() int { return fastrand.Intn(10) } // load_balance_selector_test.go func BenchmarkSelect(b *testing.B) { InitServerIndex() b.ResetTimer() for i := 0; i \u003c b.N; i++ { Select() } } func BenchmarkSelectParallel(b *testing.B) { InitServerIndex() b.ResetTimer() //b.SetParallelism(20) b.RunParallel(func(pb *testing.PB) { for pb.Next() { Select() } }) } func BenchmarkFastSelectParallel(b *testing.B) { InitServerIndex() b.ResetTimer() b.RunParallel(func(pb *testing.PB) { for pb.Next() { FastSelect() } }) } 命令：go test -bench . 基准测试以Benchmark开头，入参是testing.B，用b中的N值反复递增循环测试。 RestTimer重置计时器，在reset之前做了init或其他准备操作，这些操作不应该作为基准测试的范围； runparallel是多协程并发测试，执行两个基准测试，发现代码在并发情况存在劣化，主要原因是rand为了保证全局的随机性和并发安全，持有一把全局锁。 // rand.Intn() func Intn(n int) int { return globalRand.Intn(n) } var globalRand = New(\u0026lockedSource{src: NewSource(1).(*rngSource)}) type lockedSource struct { lk sync.Mutex src *rngSource } 优化： 为了解决随机性能问题，引入了高性能随机数方法fastrand，性能提升百倍，主要的思路是牺牲一定的数列一致性，在大多数场景适用，遇到随机场景可以尝试用fastrand。开源地址：https://github.com/bytedance/gopkg ","date":"2022-05-12","objectID":"/2022/05/go-practice/:1:3","tags":["go实践"],"title":"Golang工程实践","uri":"/2022/05/go-practice/"},{"categories":["golang"],"content":"项目实战 需求设计 以掘金社区话题入口报名页面为需求模型，该页面包括话题详情、回帖列表、支持回帖、点赞和回帖回复，开发一个服务端小功能。 需求描述： 展示话题（标题，文字描述）和回帖列表； 不考虑前端页面，实现本地web服务； 话题和回帖数据用文件存储。 需求用例：User，Topic，PostList。 两个实体的ER图： 分层结构： 数据层：数据 Model，外部数据的增删改查——Repository； 逻辑层：业务 Entity，处理核心业务逻辑输出——Service； 视图层：视图 View，处理和外部的交互逻辑——Controller。 代码开发 Repository： // topic，post model type Topic struct { Id int64 `json:\"id\"` CreateTime int64 `json:\"create_time\"` Title string `json:\"title\"` Content string `json:\"content\"` } type Post struct { Id int64 `json:\"id\"` ParentId int64 `json:\"parent_id\"` CreateTime int64 `json:\"create_time\"` Content string `json:\"content\"` } 如何实现查询：QueryTopicById, QueryPostsByParentId 对于全扫描遍历的查询，使用索引进行优化，用map实现内存索引，利用文件元数据初始化全局内存索引，实现O(1)的查找。 var ( topicIndexMap map[int64]*Topic postIndexMap map[int64][]*Post ) 初始化话题数据索引： func initTopicIndexMap(filePath string) error { open, err := os.Open(filePath + \"topic\") if err != nil { return err } scanner := bufio.NewScanner(open) topicTmpMap := make(map[int64]*Topic) for scanner.Scan() { text := scanner.Text() var topic Topic if err := json.Unmarshal([]byte(text), \u0026topic); err != nil { return err } topicTmpMap[topic.Id] = \u0026topic } topicIndexMap = topicTmpMap return nil } 初始回帖数据索引： func initPostIndexMap(filePath string) error { open, err := os.Open(filePath + \"post\") if err != nil { return err } scanner := bufio.NewScanner(open) postTmpMap := make(map[int64][]*Post) for scanner.Scan() { text := scanner.Text() var post Post if err := json.Unmarshal([]byte(text), \u0026post); err != nil { return err } posts, ok := postTmpMap[post.ParentId] if !ok { postTmpMap[post.ParentId] = []*Post{\u0026post} continue } posts = append(posts, \u0026post) postTmpMap[post.ParentId] = posts } postIndexMap = postTmpMap return nil } 使用sync.Once实现单例模式，减少存储的浪费。话题查询的实现： // topic var ( topicDao *TopicDao // singleton, space saving topicOnce sync.Once ) func NewTopicDaoInstance() *TopicDao { topicOnce.Do( func() { topicDao = \u0026TopicDao{} }) return topicDao } func (*TopicDao) QueryTopicById(id int64) *Topic { return topicIndexMap[id] } 回帖查询的实现： var ( postDao *PostDao postOnce sync.Once ) func NewPostDaoInstance() *PostDao { postOnce.Do( func() { postDao = \u0026PostDao{} }) return postDao } func (*PostDao) QueryPostByParentIdd(parentId int64) []*Post { return postIndexMap[parentId] } Service： PageInfo实体： type PageInfo struct { Topic *repository.Topic PostList []*repository.Post } 实现流程是：参数校验，准备数据，组装实体。代码流程编排： func (f *QueryPageInfoFlow) Do() (*PageInfo, error) { if err := f.checkParam(); err != nil { return nil, err } if err := f.prepareInfo(); err != nil { return nil, err } if err := f.packPageInfo(); err != nil { return nil, err } return f.pageInfo, nil } prepareInfo中，话题和回帖可以并行处理，提高执行效率。 func (f *QueryPageInfoFlow) prepareInfo() error { var wg sync.WaitGroup wg.Add(2) go func() { defer wg.Done() topic := repository.NewTopicDaoInstance().QueryTopicById(f.topicId) f.topic = topic }() go func() { defer wg.Done() posts := repository.NewPostDaoInstance().QueryPostByParentIdd(f.topicId) f.posts = posts }() wg.Wait() return nil } Controller： 构建View对象PageData，通过code msg打包业务状态信息，用data承载业务实体信息。 type PageData struct { Code int64 `json:\"code\"` Msg string `json:\"msg\"` Data interface{} `json:\"data\"` } server.go： 初始化数据索引 初始化引擎配置 构建路由 启动服务 func main() { // 1. init Index if err := repository.Init(\"./data/\"); err != nil { fmt.Printf(\"init Index failed, err:%v\\n\", err) return } // 2. init engine r := gin.Default() // 3. register router r.GET(\"/community/page/:id\", func(c *gin.Context) { topicId := c.Param(\"id\") data := controller.QueryPageInfo(topicId) c.JSON(http.StatusOK, data) }) // 4. run err := r.Run(\":9091\") if err != nil { fmt.Printf(\"run failed, err:%v\\n\", err) return } } 测试运行 命令：go build ./project-demo1 课后实践 支持发布帖子 本地Id生成需要保证不重复、唯一性（snowflake算法） Append文件，更新索引，注意Map的并发安全问题（读写锁） 完整代码见Github。 ","date":"2022-05-12","objectID":"/2022/05/go-practice/:1:4","tags":["go实践"],"title":"Golang工程实践","uri":"/2022/05/go-practice/"},{"categories":["golang"],"content":"总结 本篇主要是对Golang并发编程，依赖管理和单元测试等基础知识进行总结归纳。最后通过一个Web需求熟悉了Gin框架，对于Web开发的一个流程有了初步认识。同时对于snowflake算法和map并发安全访问也进行了实践和学习。 写blog是一个梳理思路的过程，应该循序渐进，详略得当，同时要坚持分享，这是一个良好的正反馈循环，奥利给。欢迎大家评论转载，多多发表自己的意见或建议。 ","date":"2022-05-12","objectID":"/2022/05/go-practice/:1:5","tags":["go实践"],"title":"Golang工程实践","uri":"/2022/05/go-practice/"},{"categories":["golang"],"content":"引用参考 Go by Example 中文版 Golang标准库文档 ","date":"2022-05-12","objectID":"/2022/05/go-practice/:1:6","tags":["go实践"],"title":"Golang工程实践","uri":"/2022/05/go-practice/"},{"categories":["golang"],"content":"Golang基础，包教包会，不会......，那就多读几遍","date":"2022-05-12","objectID":"/2022/05/go-basic-syntax/","tags":["go基础"],"title":"Golang基础语法","uri":"/2022/05/go-basic-syntax/"},{"categories":["golang"],"content":"Golang基础语法 | 青训笔记 这是我参与「第三届青训营 -后端场」笔记创作活动的的第1篇笔记。 从Go语言特性入手，讲述了Golang区别于其他语言的优点，通过Go by Example对基础语法进行了巩固学习。 然后对Golang常用标准库的使用和注意事项通过代码示例，最后是命令行词典和socks5代理两个小项目的实践，进一步了解Golang。 ","date":"2022-05-12","objectID":"/2022/05/go-basic-syntax/:1:0","tags":["go基础"],"title":"Golang基础语法","uri":"/2022/05/go-basic-syntax/"},{"categories":["golang"],"content":"Go语言特性 高并发，高性能 Golang是基于其他语言的痛点，开发的新时代语言。 天生支持高并发，能够充分利用多核CPU，高性能开发简单。 简单易学 标准库，工具链丰富 静态链接，快速编译 跨平台 多平台，多系统，可交叉编译，无需配置编译环境。 垃圾回收 自动管理内存释放，专注业务逻辑编程。 应用场景 公司 使用Golang开发的公司越来越多，比如国内的ByteDance，Tencent，美团，七牛云等，国外的Google，Facebook等。 领域 Golang在云计算，微服务，大数据，区块链，物联网等领域都有广泛的使用，其中在云计算，微服务领域有非常高的市场占有率。 云原生组件 Docker，Kubernetes，etcd，Prometheus等全是通过Golang实现。 ","date":"2022-05-12","objectID":"/2022/05/go-basic-syntax/:1:1","tags":["go基础"],"title":"Golang基础语法","uri":"/2022/05/go-basic-syntax/"},{"categories":["golang"],"content":"重点语法 通过Go by Example进行入门上手，对重点语法进行总结归纳。下面展示核心代码部分，完整源码，见Github仓库 数据类型 string支持+拼接，也可以通过fmt.Sprintf()，strings.Join()和buffer.WriteString()，build.WriteString()进行拼接。 str1, str2 := \"go\", \"lang\" fmt.Println(str1 + str2) fmt.Println(fmt.Sprintf(\"%s%s\", str1, str2)) fmt.Println(strings.Join([]string{str1, str2}, \"\")) var bt bytes.Buffer bt.WriteString(str1) bt.WriteString(str2) fmt.Println(bt.String()) fmt.Println(\"go\" + \"lang\") var build strings.Builder build.WriteString(str1) build.WriteString(str2) fmt.Println(build.String()) slice比array更常用，slice可以组成多维数据结构，内部长度可以不一致。slice可以模拟stack，queue。 map的键值对是无序的，可以自行按照key或value进行排序。检测key是否存在： m := make(map[string]int) if v, ok := m[\"zhangsan\"]; ok { fmt.Println(\"key exists, value:\", v) } range可对slice，map，string进行遍历，第一个参数是index(key)，第二个参数是value。 slice := []int{1, 3, 4, 6} for i, v := range slice { fmt.Println(i, v) } Go支持指针，允许通过引用传递来传递值和修改值。 值传递是数据的拷贝，会分配新的内存存储； 引用传递是指针的拷贝，共享数据的内存地址，通常使用指针是为了修改值或节约内存空间。 string等价于[]byte，Golang中字符是rune类型（uint8）, 用单引号括起来的值。 struct是带类型的字段集合，是可变的，通过构造函数封装创建结构体实例是习惯用法。 type User struct { Name string Age int } func Constructor() User { return User{Name: \"zhangsan\", Age: \"22\"} } 函数 对于多返回值函数，可用空白标识符_仅返回需要的值： func calc() (sum, sub int) { return 1+2, 1-2 } sum, _ := calc() 变参函数的使用： func sum(nums ...int) int { ans := 0 for _, num := range nums { ans += num } return ans } ans := sum(1, 2) ans = sum(1, 2, 3) // 也可以传slice nums := []int{1, 2, 3, 4} ans = sum(nums...) interface是方法签名的集合，在Go中实现一个interface就是实现其中所有方法。 如果一个变量实现了接口，就可以调用接口的方法。 可以为值类型或指针类型的接收者定义方法，想避免调用方法时产生数据拷贝或想修改接收者的值，可以选用指针来调用方法。 type User struct { Name string Age int } func (u User) ModifyInfo1() User { u.Name = \"lisi\" u.Age = 15 // u修改不成功 return u } func (u *User) ModifyInfo2() *User { u.Name = \"lisi\" u.Age = 15 // u修改成功 return u } Go习惯用独立的，明确的返回值来传递错误信息。函数的最后一个返回值常常是error类型的错误，errors.New使用给定的错误信息构造一个基本的error值。也可以使用Error()方法，自定义error类型。 在if的同一行进行错误检测是Go常用的方式。如果想在程序中使用自定义错误类型的数据，需要通过类型断言得到这个自定义错误类型的实例。 ","date":"2022-05-12","objectID":"/2022/05/go-basic-syntax/:1:2","tags":["go基础"],"title":"Golang基础语法","uri":"/2022/05/go-basic-syntax/"},{"categories":["golang"],"content":"常用标准库 fmt 输出：PrintXXX, FprintXXX, SprintXXX, ErrorfXXX fmt.Print(\"不换行\") str := \"golang\" fmt.Printf(\"%s\\n\", str) fmt.Println(\"有换行\") // Fprint将内容输出到io.Writer类型的变量中，常用在写入内容到文件 fileObj, err := os.OpenFile(\"./xx.txt\", os.O_CREATE|os.O_WRONLY|os.O_APPEND, 0644) if err != nil { fmt.Println(\"打开文件错误，err:\", err) } fmt.Fprintf(fielObj, \"向文件中写入：%s\", str) fmt.Fprintln(os.Stdout, \"向标准输出写入内容\") // Sprint把传入的数据生成并返回一个字符串 s1 := fmt.Sprint(\"golang\") s2 := fmt.Sprintf(\"s1:%s\", s1) s3 := fmt.Sprtinln(\"golang有换行\") // Errof根据format参数生成格式化字符串并返回一个包含该字符串的错误, 通常用来自定义错误类型 err := fmt.Errof(\"这是一个自定义错误类型\") 输入：ScanXXX var name string var age int fmt.Scan(\u0026name, \u0026age) fmt.Scanf(\"%s, %d\\n\", \u0026name, \u0026age) fmt.Scanln(\u0026name, \u0026age) // 遇到换行才停止 // 如果想要获取包含空格等完整输入内容，可以用bufio.NewReader reader := bufio.NewReader(os.Stdin) text, _ := reader.ReadString(\"\\n\") text = strings.TrimSpace(text) fmt.Printf(\"%#v\\n\", text) 输入还有FscanXXX从io.Reader读取和ScanXXX从指定字符串读取。 time 时间戳： now := time.Now() timestamp1 := now.Unix() // 时间戳 timestamp2 := now.UnixNano() // 纳秒级时间戳 时间间隔：time.Duration表示1ns，time.Second表示1s 时间格式化，以Go的诞生时间固定格式模板： now := time.Now() fmt.Println(now.Format(\"2006-01-02 15:04:05.000 Mon Jan\")) strconv string和int的转换： num := strconv.Atoi(\"123\") str := strconv.Itoa(num) ParseXXX将字符串转换为给定类型： boolType, err := strconv.ParseBool(\"true\") intType, err := strconv.ParseInt(\"23\", 10, 64) // 10进制，int64 floatType, err := strconv.ParseFloat(\"3.14\", 64) // float64 uintType, err := strconv.ParseUint(\"23\", 64) // uint64 FormatXX将给定类型转换为string。 strings 包括了操作字符的常用函数，比如大小写转换，是否有指定前缀或后缀，字符串拼接或分离等。 str := \"golang\" strings.Contains(str, \"lang\") strings.HasPrefix(str, \"go\") strings.ToUpper(str) strings.Replace(str, \"g\", \"G\", -1) encoding/json 这个包实现了对json的编码和解码。 // 序列化，其他数据类型转json type User struct { Name string `json:\"name\"` Age int `json:\"age\"` } u := User{Name:\"zhangsan\", Age:\"18\"} buf, err := json.Marshal(u) if err != nil { panic(err) } fmt.Println(string(buf)) // 反序列化，json转其他数据类型 var u2 User err = json.Unmarshal(buf, \u0026u2) if err != nil { panic(err) } fmt.Printf(\"%#v\\n\", u2) ","date":"2022-05-12","objectID":"/2022/05/go-basic-syntax/:1:3","tags":["go基础"],"title":"Golang基础语法","uri":"/2022/05/go-basic-syntax/"},{"categories":["golang"],"content":"实战练习 命令行词典 需求：调用第三方翻译API实现一个命令行词典，使用格式：simpleDict word 分析：整个过程主要是三个步骤：发送HTTP请求，解析响应json，打印出结果。 抓包，打开彩云小译，按F12，输入你要翻译的单词，比如translate, 可在DevTools的Network查看HTTP的post请求信息： 生成代码，右键copy as curl(bash)，复制curl命令。在终端可以返回这个请求的json代码，我们直接使用在线curl2go生成该请求的Golang代码, 运行该代码同样能得到请求的json代码，也就是服务器返回给我们的响应体信息： 从代码可以知道我们需要构造相应的request和response结构体，response结构体可以通过oktools在线生成，只需将DevTools中response的json复制粘贴，转换嵌套即可： 从结构体当中找到我们需要返回打印的指定字段值，完善优化修改代码即可。 同理，对火山翻译和有道智云两个API进行Golang代码生成，其他第三方API也是同样的道理，只不过可能request和response的相关信息不好找或者经过Hash等处理。 最后实现了三方引擎并行的一个命令行翻译词典，运行结果如下图，完整源码： proxy socks5代理协议，是明文传输，它的用途主要是作为一道屏障隔绝内部网络与互联网，并且使两者联系起来。比如某些企业的内网为确保安全性，有严格的防火墙策略，带来的副作用就是访问某些资源很麻烦。socks5相当于在防火墙开了一个口子，让授权的用户，可以通过单个端口去访问内部的所有资源。 同样地，网络爬虫在爬取过程中，很容易遇到IP访问频率超过限制，为了突破限制，人们就会去网上找代理IP池，这些代理IP池里面的很多协议就是socks5协议。 socks5代理过程： 主要分为4个阶段： 握手阶段： 浏览器向socks5代理发送请求，包的内容包括了一个协议的版本号，支持的认证种类，socks5服务器会选中一个认证方式，返回给浏览器，如果返回的是00就代表不需要认证，返回其他类型会开始认证流程，对认证流程不再详述； 认证阶段： 认证阶段作为协商的一个子流程，它不是必须的。socks5服务器可以决定是否需要认证，如果不需要认证，那么认证阶段会被直接略过。 如果需要认证，客户端向socks5服务器发起一个认证请求，包括：版本， 用户名长度，对应用户名的字节数据，密码长度，密码对应的数据。 socks5服务器收到客户端的认证请求后，解析内容，验证信息是否合法，然后给客户端响应结果，包括：版本，状态，如果STATUS字段为0x00表示认证成功，其他的值为认证失败。当客户端收到认证失败的响应后，它将会断开连接。 请求阶段： 认证通过以后，浏览器会向socks5服务器发起请求，主要信息包括版本号，请求的类型，主要是connection请求，代表代理服务器要和某个域名或某个IP地址某个端口建立TCP连接，代理服务器收到响应后，会真正和后端服务器建立连接，返回一个响应； relay阶段： 浏览器正常发送请求，代理服务器收到请求，将请求转换到真正的服务器，真的服务器返回响应，也会给代理服务器转发给浏览器，代理服务器不关心流量的细节，可以是HTTP流量，也可以是TCP流量，这就socks5的工作原理。 需求：启动程序后，通过浏览器配置代理，代理服务器的日志会打印出你访问的网站的域名或者IP，也就是你的网络流量都会经过这个代理服务器。 分析： tcp echo server 服务端监听你的信息并将其打印。 auth 浏览器会给代理服务器发送一个包，包括三个字段version，methods，methods的编码，代理服务器需要返回一个response，包括两个字段version，method。 request 读取携带的URL或IP+端口的包，并把它打印。 请求包，包括6个字段，version，command，RSV，atype，addr，port。 relay 用net.dial建立一个TCP连接，并启动两个goroutine，通过io.copy建立浏览器和下游服务器的双向数据转发。 需要使用context机制，等待ctx.Done()避免connect函数立刻返回，连接关闭。 通过switchOmega插件，实现网络流量代理，完整源码： ","date":"2022-05-12","objectID":"/2022/05/go-basic-syntax/:1:4","tags":["go基础"],"title":"Golang基础语法","uri":"/2022/05/go-basic-syntax/"},{"categories":["golang"],"content":"总结 本篇主要对Golang基础的重点易错点，几个常用标准库的使用方法进行了总结记录，并且通过两个小项目对Go语言上手实践，新手丝滑入门Golang。 第一篇blog，大纲目录比较乱，总是修修改改，后边找个时间整理一下写blog的过程（挖坑）。欢迎大家评论转载，多多发表自己的意见或建议。 （ps：blog写得真慢，要搞快点！！！） ","date":"2022-05-12","objectID":"/2022/05/go-basic-syntax/:1:5","tags":["go基础"],"title":"Golang基础语法","uri":"/2022/05/go-basic-syntax/"},{"categories":["golang"],"content":"引用参考 Go by Example 中文版 Golang标准库文档 ","date":"2022-05-12","objectID":"/2022/05/go-basic-syntax/:1:6","tags":["go基础"],"title":"Golang基础语法","uri":"/2022/05/go-basic-syntax/"}]