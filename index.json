[{"categories":["golang"],"content":"go语言基础实践，巩固基础语法...","date":"2022-05-12","objectID":"/2022/05/go-practice/","tags":["go实践"],"title":"Golang工程实践","uri":"/2022/05/go-practice/"},{"categories":["golang"],"content":"Golang工程实践 | 青训笔记 这是我参与「第三届青训营 -后端场」笔记创作活动的的第2篇笔记。 继续通过Go by Example对基础语法进行巩固，本篇总结了与并发编程相关的基础语法，如通道、协程和WaitGroup等。同时对Golang依赖管理Go Module的使用进行总结，对Go程序如何进行单元测试以及相关注意事项进行总结。最后是以“青训营话题页”为需求，进行项目实战，主要实现了话题和回帖的查询功能和发帖功能。完整代码见Github。 ","date":"2022-05-12","objectID":"/2022/05/go-practice/:1:0","tags":["go实践"],"title":"Golang工程实践","uri":"/2022/05/go-practice/"},{"categories":["golang"],"content":"并发编程语法 通道 goroutine是轻量级的执行线程，通过关键字go就能同步或异步启动一个协程。Go runtime是以并发的方式运行协程。 func f(from string) { for i := 0; i \u003c 3; i++ { fmt.Println(from, \":\", i) } } f(\"direct\") // 直接调用函数 go f(\"goroutine\") // 启动协程调用函数 channel是连接多个goroutine的管道，可以从一个goroutine发送数据给channel，另一个goroutine从channel接收数据。默认发送和接收都是阻塞的，也就是说默认的channel是同步操作。 messages := make(chan string) go func() { messages \u003c- \"ping\" }() msg := \u003c- messages fmt.Println(msg) 默认channel是无缓冲的，所以能够实现同步。有缓冲的channel能够实现异步。 messages := make(chan string, 2) messages \u003c- \"buffered\" messages \u003c- \"channel\" fmt.Println(\u003c-messages) fmt.Println(\u003c-messages) 通过无缓冲channel，以阻塞接收的方式实现同步。 func worker(done chan bool) { fmt.Print(\"working...\") time.Sleep(time.Second) fmt.Println(\"done\") done \u003c- true } done := make(chan bool) go worker(done) // 阻塞接收 \u003c- done channel作为函数参数，可以指定方向，是否只读或只写，可以提升程序的安全性。 pings := make(chan\u003c- string) // 只写 pongs := make(\u003c-chan string) // 只读 select可以同时等待多个channel，选择channel执行。 使用带default的select实现非阻塞通道的发送、接收，也可以实现非阻塞的多路select。 messages := make(chan string) // 非阻塞接收 select { case msg := \u003c- messages: fmt.Println(\"received message\", msg) default: fmt.Println(\"no message received\") } // 非阻塞发送 msg := \"hi\" select { case messages \u003c- msg: fmt.Println(\"sent message\", msg) default: fmt.Println(\"no message sent\") } 通过channel和select可以进行超时处理。 当关闭一个channel以后，就不能再发送数据给channel，因此可以向channel的接收方传达工作已经完成的信息。 线程和协程的区别： 一个线程可以有多个协程，协程是轻量级线程； 线程栈MB级别，协程栈KB级别。 定时 Go可以通过Timer设置在未来某个时间点运行Go代码。 // 定时器等待2s timer1 := time.NewTimer(2*time.Second) // 一直阻塞，直到C明确发送定时器失效的值 \u003c-timer1.C fmt.Println(\"Timer 1 fired\") 当你想要以固定的时间间隔重复执行，可以使用Ticker。 // 数据每隔500ms到达 ticker := time.NewTicker(500*time.Millisecond) done := make(chan bool) go func() { for { select { case \u003c- done: return case t := \u003c-ticker.C: fmt.Println(\"Tick at\", t) } } }() // 等待1600ms后，停止ticker time.Sleep(1600*time.Millisecond) ticker.Stop() done \u003c- true fmt.Println(\"Ticker stopped\") Golang可以基于goroutine、channel和timer实现速率限制。速率限制是控制服务资源利用和质量的重要机制。 WaitGroup 使用WaitGroup等待多个goroutine完成。 func worker(id int) { fmt.Printf(\"Worker %d strarting\\n\", id) time.Sleep(time.Second) fmt.Printf(\"Worker %d done\\n\", id) } func main() { var wg sync.WaitGroup // 启动goroutine，并递增WaitGroup的计数器 for i := 1; i \u003c= 5; i++ { wg.Add(1) i := i // 将worker调用封装到一个闭包中，可以确保通知WaitGroup，此工作线程已完成 // worker线程本身也就不需要知道执行涉及的并发原语 go func() { defer wg.Done() worker(i) }() } // 阻塞，直到WaitGroup计数器恢复为0 wg.Wait() } Go的状态管理机制主要是依靠channel的通信来完成的，通过sync/atomic可以实现多个goroutine间的原子计数。 func main() { // 无符号整型变量表示计数器 var ops uint64 // 等待所有goroutine完成工作 var wg sync.WaitGroup // 启动50个goroutine，每个goroutine会将计数器递增1000次 for i := 0; i \u003c 50; i++ { wg.Add(1) go func() { for c := 0; c \u003c 1000; c++ { // 使用AddUint64让计数器自增 atomic.AddUint64(\u0026ops, 1) } wg.Done() }() } // 等待所有goroutine结束 wg.Wait() // 安全访问ops, 50000 fmt.Println(\"ops:\", ops) } 使用互斥量在Go协程间安全访问数据。 type Container struct { mu sync.Mutex counters map[string]int } func (c *Container) inc(name string) { // 互斥访问counters，实现数据同步 c.mu.Lock() defer c.mu.Unlock() c.counters[name]++ } Go共享内存的思想是，通过通信使每个数据仅被单个协程拥有，也就是通过通信实现共享内存。 WaitGroup的Add对计数器加1，Done对计数器减一，Wait主线程阻塞直到计数器为0。 ","date":"2022-05-12","objectID":"/2022/05/go-practice/:1:1","tags":["go实践"],"title":"Golang工程实践","uri":"/2022/05/go-practice/"},{"categories":["golang"],"content":"依赖管理 Go语言包的依赖管理主要有两个问题： 如何控制不同环境（项目）依赖的版本； 如何控制依赖库的版本。 演进过程 GOPATH：是Go的环境变量，它无法满足不同项目依赖同一个库的不同版本； 项目A和项目B依赖于同一package的不同版本，依赖冲突。 Go Vendor：将依赖包副本存放在Vendor目录下，可以满足多个项目需要同一个package的不同版本的需求；但无法控制依赖库的版本，更新项目可能出现依赖冲突，导致编译出错； 项目A的依赖库package D的不同版本无法兼容，依赖冲突。 Go Module： Go官方推出的依赖管理系统，解决了上诉两个依赖管理问题。通过go.mod文件管理依赖包版本，通过go get/go mod命令工具管理依赖包。 Go Module 依赖管理三要素： 配置文件，描述依赖——go.mod; 中心仓库管理依赖库——Proxy; 本地工具——go get/go mod。 依赖配置 项目多库依赖中，依赖配置选择最低的兼容版本。 依赖分发 直接使用版本管理仓库下载依赖，主要存在3个问题： 无法保证构建稳定性：如果软件作者增加/修改/删除软件版本，会导致构建使用其他版本的依赖，或者找不到依赖版本； 无法保证依赖可用性：如果软件作者直接从代码平台删除软件，会保证依赖不可用； 增加第三方压力：给代码托管平台增加负载压力。 go proxy能够解决这些问题，它会缓存源站的软件内容，缓存的软件版本不会改变，在源站删除软件之后也能使用，实现了immutability和available的依赖分发。 Go Module通过GOPROXY环境变量控制go proxy的使用。示例配置： GOPROXY=\"https://proxy1.cn, https://proxy2.cn, direct\" 整体的依赖寻址路径，会优先从proxy1下载；如果proxy1不存在，就从proxy2下载；如果proxy2不存在，就从direct（源站）下载，并缓存到proxy1，proxy2站点中。 工具 go get go get example.org/pkg@XXX // XXX:update 默认 // XXX:none 删除依赖 // XXX:v1.1.2 tag版本，语义版本 // XXX:23dfdd5 特定的commit // XXX:master 分支的最新commit go mod go mod init projName // 初始化，创建go.mod文件 go mod tidy // 增加需要的依赖，删除不需要的依赖 go mod download // 下载模块到本地缓存 go mod graph // 打印依赖图 go mod verify // 校验依赖 ","date":"2022-05-12","objectID":"/2022/05/go-practice/:1:2","tags":["go实践"],"title":"Golang工程实践","uri":"/2022/05/go-practice/"},{"categories":["golang"],"content":"测试 分类 软件测试能够反映系统的质量问题，质量问题决定着系统的稳定性，如果线上系统出现bug，就会造成事故，而事故直接和收益挂钩。如何避免事故的发生，就要通过完备的测试。 测试分为： 回归测试：QA手动通过终端回归一些固定的主流程场景； 集成测试：对系统功能维度进行测试验证； 单元测试：测试开发阶段，开发者对单独的函数，模块做功能验证。 三者的层级从上至下，测试成本逐渐减少，而测试覆盖率逐渐上升，所以单元测试的覆盖率一定程度决定代码质量。 单元测试 单元测试主要包括：输入、测试单元、输出以及校对。测试单元有接口、函数和模块等，校对可以保证代码的功能与我们的预期是否相符。 单元测试一方面保证质量，在整体覆盖率足够的情况下，一定程度上既保证了新功能本身的正确性，又未破坏原有代码的正确性。另一方面可以提升效率，在代码有bug的情况下，通过编写单元测试，可以在一个较短周期内定位和修复问题。 规则： 所有测试文件以_test.go结尾； func TestXXX(*testing.T)，被测函数首字母需要大写； 初始化逻辑放到TestMain中。 代码覆盖率： 衡量代码是否经过足够的测试； 评价项目的测试水准； 评估项目是否达到高水准测试等级。 例子： // judgement.go func JudgePassLine(score int16) bool { if score \u003e= 60 { return true } return false } // judgement_test.go func TestJudgePassLineTre(t *testing.T) { output := JudgePassLine(70) expectOutput := true assert.Equal(t, expectOutput, output) } func TestJudgePassLineFalse(t *testing.T) { output := JudgePassLine(50) expectOutput := false assert.Equal(t, expectOutput, output) } // 命令：go test judgement_test.go judgement.go --cover // 结果：ok command-line-arguments 0.711s coverage: 100.0% of statements 测试tips： 实际项目中，一般要求的是50%~60%的覆盖率，对于资金型服务，覆盖率要求达到80%+； 测试分支要相互独立，全面覆盖； 测试单元粒度要足够小，要符合函数设计的单一职责。 依赖： 工程中复杂的项目，单元测试会依赖File、DB和Cache等外部依赖；单元测试需要保证稳定性和幂等性。 稳定性是指相互隔离，能在任何时间、任何环境运行测试； 幂等性是指每一次的测试运行都应该产生和之前一样的结果。 Mock机制可以实现稳定性和幂等性。 Mock测试 使用Monkey mock测试库：https://github.com/bouk/monkey。它可以对method或者实例的方法进行mock、反射和指针赋值。 Monkey Patch的作用域在Runtime，在运行时通过Go的unsafe包，能够将内存中函数的地址替换为运行时函数的地址。将待打桩函数或方法的实现跳转。具体代码见Github。 基准测试 基准测试是指测试一段程序的运行性能以及耗费CPU的程度。在实际项目开发中，经常会遇到代码性能瓶颈，为了定位问题经常要对代码做性能分析，就会用到基准测试。 服务器负载均衡例子，随机选择执行服务器： // load_balance_selector.go var ServerIndex [10]int func InitServerIndex() { for i := 0; i \u003c 10; i++ { ServerIndex[i] = i } } func Select() int { return rand.Intn(10) } func FastSelect() int { return fastrand.Intn(10) } // load_balance_selector_test.go func BenchmarkSelect(b *testing.B) { InitServerIndex() b.ResetTimer() for i := 0; i \u003c b.N; i++ { Select() } } func BenchmarkSelectParallel(b *testing.B) { InitServerIndex() b.ResetTimer() //b.SetParallelism(20) b.RunParallel(func(pb *testing.PB) { for pb.Next() { Select() } }) } func BenchmarkFastSelectParallel(b *testing.B) { InitServerIndex() b.ResetTimer() b.RunParallel(func(pb *testing.PB) { for pb.Next() { FastSelect() } }) } 命令：go test -bench . 基准测试以Benchmark开头，入参是testing.B，用b中的N值反复递增循环测试。 RestTimer重置计时器，在reset之前做了init或其他准备操作，这些操作不应该作为基准测试的范围； runparallel是多协程并发测试，执行两个基准测试，发现代码在并发情况存在劣化，主要原因是rand为了保证全局的随机性和并发安全，持有一把全局锁。 // rand.Intn() func Intn(n int) int { return globalRand.Intn(n) } var globalRand = New(\u0026lockedSource{src: NewSource(1).(*rngSource)}) type lockedSource struct { lk sync.Mutex src *rngSource } 优化： 为了解决随机性能问题，引入了高性能随机数方法fastrand，性能提升百倍，主要的思路是牺牲一定的数列一致性，在大多数场景适用，遇到随机场景可以尝试用fastrand。开源地址：https://github.com/bytedance/gopkg ","date":"2022-05-12","objectID":"/2022/05/go-practice/:1:3","tags":["go实践"],"title":"Golang工程实践","uri":"/2022/05/go-practice/"},{"categories":["golang"],"content":"项目实战 需求设计 以掘金社区话题入口报名页面为需求模型，该页面包括话题详情、回帖列表、支持回帖、点赞和回帖回复，开发一个服务端小功能。 需求描述： 展示话题（标题，文字描述）和回帖列表； 不考虑前端页面，实现本地web服务； 话题和回帖数据用文件存储。 需求用例：User，Topic，PostList。 两个实体的ER图： 分层结构： 数据层：数据 Model，外部数据的增删改查——Repository； 逻辑层：业务 Entity，处理核心业务逻辑输出——Service； 视图层：视图 View，处理和外部的交互逻辑——Controller。 代码开发 Repository： // topic，post model type Topic struct { Id int64 `json:\"id\"` CreateTime int64 `json:\"create_time\"` Title string `json:\"title\"` Content string `json:\"content\"` } type Post struct { Id int64 `json:\"id\"` ParentId int64 `json:\"parent_id\"` CreateTime int64 `json:\"create_time\"` Content string `json:\"content\"` } 如何实现查询：QueryTopicById, QueryPostsByParentId 对于全扫描遍历的查询，使用索引进行优化，用map实现内存索引，利用文件元数据初始化全局内存索引，实现O(1)的查找。 var ( topicIndexMap map[int64]*Topic postIndexMap map[int64][]*Post ) 初始化话题数据索引： func initTopicIndexMap(filePath string) error { open, err := os.Open(filePath + \"topic\") if err != nil { return err } scanner := bufio.NewScanner(open) topicTmpMap := make(map[int64]*Topic) for scanner.Scan() { text := scanner.Text() var topic Topic if err := json.Unmarshal([]byte(text), \u0026topic); err != nil { return err } topicTmpMap[topic.Id] = \u0026topic } topicIndexMap = topicTmpMap return nil } 初始回帖数据索引： func initPostIndexMap(filePath string) error { open, err := os.Open(filePath + \"post\") if err != nil { return err } scanner := bufio.NewScanner(open) postTmpMap := make(map[int64][]*Post) for scanner.Scan() { text := scanner.Text() var post Post if err := json.Unmarshal([]byte(text), \u0026post); err != nil { return err } posts, ok := postTmpMap[post.ParentId] if !ok { postTmpMap[post.ParentId] = []*Post{\u0026post} continue } posts = append(posts, \u0026post) postTmpMap[post.ParentId] = posts } postIndexMap = postTmpMap return nil } 使用sync.Once实现单例模式，减少存储的浪费。话题查询的实现： // topic var ( topicDao *TopicDao // singleton, space saving topicOnce sync.Once ) func NewTopicDaoInstance() *TopicDao { topicOnce.Do( func() { topicDao = \u0026TopicDao{} }) return topicDao } func (*TopicDao) QueryTopicById(id int64) *Topic { return topicIndexMap[id] } 回帖查询的实现： var ( postDao *PostDao postOnce sync.Once ) func NewPostDaoInstance() *PostDao { postOnce.Do( func() { postDao = \u0026PostDao{} }) return postDao } func (*PostDao) QueryPostByParentIdd(parentId int64) []*Post { return postIndexMap[parentId] } Service： PageInfo实体： type PageInfo struct { Topic *repository.Topic PostList []*repository.Post } 实现流程是：参数校验，准备数据，组装实体。代码流程编排： func (f *QueryPageInfoFlow) Do() (*PageInfo, error) { if err := f.checkParam(); err != nil { return nil, err } if err := f.prepareInfo(); err != nil { return nil, err } if err := f.packPageInfo(); err != nil { return nil, err } return f.pageInfo, nil } prepareInfo中，话题和回帖可以并行处理，提高执行效率。 func (f *QueryPageInfoFlow) prepareInfo() error { var wg sync.WaitGroup wg.Add(2) go func() { defer wg.Done() topic := repository.NewTopicDaoInstance().QueryTopicById(f.topicId) f.topic = topic }() go func() { defer wg.Done() posts := repository.NewPostDaoInstance().QueryPostByParentIdd(f.topicId) f.posts = posts }() wg.Wait() return nil } Controller： 构建View对象PageData，通过code msg打包业务状态信息，用data承载业务实体信息。 type PageData struct { Code int64 `json:\"code\"` Msg string `json:\"msg\"` Data interface{} `json:\"data\"` } server.go： 初始化数据索引 初始化引擎配置 构建路由 启动服务 func main() { // 1. init Index if err := repository.Init(\"./data/\"); err != nil { fmt.Printf(\"init Index failed, err:%v\\n\", err) return } // 2. init engine r := gin.Default() // 3. register router r.GET(\"/community/page/:id\", func(c *gin.Context) { topicId := c.Param(\"id\") data := controller.QueryPageInfo(topicId) c.JSON(http.StatusOK, data) }) // 4. run err := r.Run(\":9091\") if err != nil { fmt.Printf(\"run failed, err:%v\\n\", err) return } } 测试运行 命令：go build ./project-demo1 课后实践 支持发布帖子 本地Id生成需要保证不重复、唯一性（snowflake算法） Append文件，更新索引，注意Map的并发安全问题（读写锁） 完整代码见Github。 ","date":"2022-05-12","objectID":"/2022/05/go-practice/:1:4","tags":["go实践"],"title":"Golang工程实践","uri":"/2022/05/go-practice/"},{"categories":["golang"],"content":"总结 本篇主要是对Golang并发编程，依赖管理和单元测试等基础知识进行总结归纳。最后通过一个Web需求熟悉了Gin框架，对于Web开发的一个流程有了初步认识。同时对于snowflake算法和map并发安全访问也进行了实践和学习。 写blog是一个梳理思路的过程，应该循序渐进，详略得当，同时要坚持分享，这是一个良好的正反馈循环，奥利给。欢迎大家评论转载，多多发表自己的意见或建议。 ","date":"2022-05-12","objectID":"/2022/05/go-practice/:1:5","tags":["go实践"],"title":"Golang工程实践","uri":"/2022/05/go-practice/"},{"categories":["golang"],"content":"引用参考 Go by Example 中文版 Golang标准库文档 ","date":"2022-05-12","objectID":"/2022/05/go-practice/:1:6","tags":["go实践"],"title":"Golang工程实践","uri":"/2022/05/go-practice/"},{"categories":["golang"],"content":"Golang基础，包教包会，不会......，那就多读几遍","date":"2022-05-12","objectID":"/2022/05/go-basic-syntax/","tags":["go基础"],"title":"Golang基础语法","uri":"/2022/05/go-basic-syntax/"},{"categories":["golang"],"content":"Golang基础语法 | 青训笔记 这是我参与「第三届青训营 -后端场」笔记创作活动的的第1篇笔记。 从Go语言特性入手，讲述了Golang区别于其他语言的优点，通过Go by Example对基础语法进行了巩固学习。 然后对Golang常用标准库的使用和注意事项通过代码示例，最后是命令行词典和socks5代理两个小项目的实践，进一步了解Golang。 ","date":"2022-05-12","objectID":"/2022/05/go-basic-syntax/:1:0","tags":["go基础"],"title":"Golang基础语法","uri":"/2022/05/go-basic-syntax/"},{"categories":["golang"],"content":"Go语言特性 高并发，高性能 Golang是基于其他语言的痛点，开发的新时代语言。 天生支持高并发，能够充分利用多核CPU，高性能开发简单。 简单易学 标准库，工具链丰富 静态链接，快速编译 跨平台 多平台，多系统，可交叉编译，无需配置编译环境。 垃圾回收 自动管理内存释放，专注业务逻辑编程。 应用场景 公司 使用Golang开发的公司越来越多，比如国内的ByteDance，Tencent，美团，七牛云等，国外的Google，Facebook等。 领域 Golang在云计算，微服务，大数据，区块链，物联网等领域都有广泛的使用，其中在云计算，微服务领域有非常高的市场占有率。 云原生组件 Docker，Kubernetes，etcd，Prometheus等全是通过Golang实现。 ","date":"2022-05-12","objectID":"/2022/05/go-basic-syntax/:1:1","tags":["go基础"],"title":"Golang基础语法","uri":"/2022/05/go-basic-syntax/"},{"categories":["golang"],"content":"重点语法 通过Go by Example进行入门上手，对重点语法进行总结归纳。下面展示核心代码部分，完整源码，见Github仓库 数据类型 string支持+拼接，也可以通过fmt.Sprintf()，strings.Join()和buffer.WriteString()，build.WriteString()进行拼接。 str1, str2 := \"go\", \"lang\" fmt.Println(str1 + str2) fmt.Println(fmt.Sprintf(\"%s%s\", str1, str2)) fmt.Println(strings.Join([]string{str1, str2}, \"\")) var bt bytes.Buffer bt.WriteString(str1) bt.WriteString(str2) fmt.Println(bt.String()) fmt.Println(\"go\" + \"lang\") var build strings.Builder build.WriteString(str1) build.WriteString(str2) fmt.Println(build.String()) slice比array更常用，slice可以组成多维数据结构，内部长度可以不一致。slice可以模拟stack，queue。 map的键值对是无序的，可以自行按照key或value进行排序。检测key是否存在： m := make(map[string]int) if v, ok := m[\"zhangsan\"]; ok { fmt.Println(\"key exists, value:\", v) } range可对slice，map，string进行遍历，第一个参数是index(key)，第二个参数是value。 slice := []int{1, 3, 4, 6} for i, v := range slice { fmt.Println(i, v) } Go支持指针，允许通过引用传递来传递值和修改值。 值传递是数据的拷贝，会分配新的内存存储； 引用传递是指针的拷贝，共享数据的内存地址，通常使用指针是为了修改值或节约内存空间。 string等价于[]byte，Golang中字符是rune类型（uint8）, 用单引号括起来的值。 struct是带类型的字段集合，是可变的，通过构造函数封装创建结构体实例是习惯用法。 type User struct { Name string Age int } func Constructor() User { return User{Name: \"zhangsan\", Age: \"22\"} } 函数 对于多返回值函数，可用空白标识符_仅返回需要的值： func calc() (sum, sub int) { return 1+2, 1-2 } sum, _ := calc() 变参函数的使用： func sum(nums ...int) int { ans := 0 for _, num := range nums { ans += num } return ans } ans := sum(1, 2) ans = sum(1, 2, 3) // 也可以传slice nums := []int{1, 2, 3, 4} ans = sum(nums...) interface是方法签名的集合，在Go中实现一个interface就是实现其中所有方法。 如果一个变量实现了接口，就可以调用接口的方法。 可以为值类型或指针类型的接收者定义方法，想避免调用方法时产生数据拷贝或想修改接收者的值，可以选用指针来调用方法。 type User struct { Name string Age int } func (u User) ModifyInfo1() User { u.Name = \"lisi\" u.Age = 15 // u修改不成功 return u } func (u *User) ModifyInfo2() *User { u.Name = \"lisi\" u.Age = 15 // u修改成功 return u } Go习惯用独立的，明确的返回值来传递错误信息。函数的最后一个返回值常常是error类型的错误，errors.New使用给定的错误信息构造一个基本的error值。也可以使用Error()方法，自定义error类型。 在if的同一行进行错误检测是Go常用的方式。如果想在程序中使用自定义错误类型的数据，需要通过类型断言得到这个自定义错误类型的实例。 ","date":"2022-05-12","objectID":"/2022/05/go-basic-syntax/:1:2","tags":["go基础"],"title":"Golang基础语法","uri":"/2022/05/go-basic-syntax/"},{"categories":["golang"],"content":"常用标准库 fmt 输出：PrintXXX, FprintXXX, SprintXXX, ErrorfXXX fmt.Print(\"不换行\") str := \"golang\" fmt.Printf(\"%s\\n\", str) fmt.Println(\"有换行\") // Fprint将内容输出到io.Writer类型的变量中，常用在写入内容到文件 fileObj, err := os.OpenFile(\"./xx.txt\", os.O_CREATE|os.O_WRONLY|os.O_APPEND, 0644) if err != nil { fmt.Println(\"打开文件错误，err:\", err) } fmt.Fprintf(fielObj, \"向文件中写入：%s\", str) fmt.Fprintln(os.Stdout, \"向标准输出写入内容\") // Sprint把传入的数据生成并返回一个字符串 s1 := fmt.Sprint(\"golang\") s2 := fmt.Sprintf(\"s1:%s\", s1) s3 := fmt.Sprtinln(\"golang有换行\") // Errof根据format参数生成格式化字符串并返回一个包含该字符串的错误, 通常用来自定义错误类型 err := fmt.Errof(\"这是一个自定义错误类型\") 输入：ScanXXX var name string var age int fmt.Scan(\u0026name, \u0026age) fmt.Scanf(\"%s, %d\\n\", \u0026name, \u0026age) fmt.Scanln(\u0026name, \u0026age) // 遇到换行才停止 // 如果想要获取包含空格等完整输入内容，可以用bufio.NewReader reader := bufio.NewReader(os.Stdin) text, _ := reader.ReadString(\"\\n\") text = strings.TrimSpace(text) fmt.Printf(\"%#v\\n\", text) 输入还有FscanXXX从io.Reader读取和ScanXXX从指定字符串读取。 time 时间戳： now := time.Now() timestamp1 := now.Unix() // 时间戳 timestamp2 := now.UnixNano() // 纳秒级时间戳 时间间隔：time.Duration表示1ns，time.Second表示1s 时间格式化，以Go的诞生时间固定格式模板： now := time.Now() fmt.Println(now.Format(\"2006-01-02 15:04:05.000 Mon Jan\")) strconv string和int的转换： num := strconv.Atoi(\"123\") str := strconv.Itoa(num) ParseXXX将字符串转换为给定类型： boolType, err := strconv.ParseBool(\"true\") intType, err := strconv.ParseInt(\"23\", 10, 64) // 10进制，int64 floatType, err := strconv.ParseFloat(\"3.14\", 64) // float64 uintType, err := strconv.ParseUint(\"23\", 64) // uint64 FormatXX将给定类型转换为string。 strings 包括了操作字符的常用函数，比如大小写转换，是否有指定前缀或后缀，字符串拼接或分离等。 str := \"golang\" strings.Contains(str, \"lang\") strings.HasPrefix(str, \"go\") strings.ToUpper(str) strings.Replace(str, \"g\", \"G\", -1) encoding/json 这个包实现了对json的编码和解码。 // 序列化，其他数据类型转json type User struct { Name string `json:\"name\"` Age int `json:\"age\"` } u := User{Name:\"zhangsan\", Age:\"18\"} buf, err := json.Marshal(u) if err != nil { panic(err) } fmt.Println(string(buf)) // 反序列化，json转其他数据类型 var u2 User err = json.Unmarshal(buf, \u0026u2) if err != nil { panic(err) } fmt.Printf(\"%#v\\n\", u2) ","date":"2022-05-12","objectID":"/2022/05/go-basic-syntax/:1:3","tags":["go基础"],"title":"Golang基础语法","uri":"/2022/05/go-basic-syntax/"},{"categories":["golang"],"content":"实战练习 命令行词典 需求：调用第三方翻译API实现一个命令行词典，使用格式：simpleDict word 分析：整个过程主要是三个步骤：发送HTTP请求，解析响应json，打印出结果。 抓包，打开彩云小译，按F12，输入你要翻译的单词，比如translate, 可在DevTools的Network查看HTTP的post请求信息： 生成代码，右键copy as curl(bash)，复制curl命令。在终端可以返回这个请求的json代码，我们直接使用在线curl2go生成该请求的Golang代码, 运行该代码同样能得到请求的json代码，也就是服务器返回给我们的响应体信息： 从代码可以知道我们需要构造相应的request和response结构体，response结构体可以通过oktools在线生成，只需将DevTools中response的json复制粘贴，转换嵌套即可： 从结构体当中找到我们需要返回打印的指定字段值，完善优化修改代码即可。 同理，对火山翻译和有道智云两个API进行Golang代码生成，其他第三方API也是同样的道理，只不过可能request和response的相关信息不好找或者经过Hash等处理。 最后实现了三方引擎并行的一个命令行翻译词典，运行结果如下图，完整源码： proxy socks5代理协议，是明文传输，它的用途主要是作为一道屏障隔绝内部网络与互联网，并且使两者联系起来。比如某些企业的内网为确保安全性，有严格的防火墙策略，带来的副作用就是访问某些资源很麻烦。socks5相当于在防火墙开了一个口子，让授权的用户，可以通过单个端口去访问内部的所有资源。 同样地，网络爬虫在爬取过程中，很容易遇到IP访问频率超过限制，为了突破限制，人们就会去网上找代理IP池，这些代理IP池里面的很多协议就是socks5协议。 socks5代理过程： 主要分为4个阶段： 握手阶段： 浏览器向socks5代理发送请求，包的内容包括了一个协议的版本号，支持的认证种类，socks5服务器会选中一个认证方式，返回给浏览器，如果返回的是00就代表不需要认证，返回其他类型会开始认证流程，对认证流程不再详述； 认证阶段： 认证阶段作为协商的一个子流程，它不是必须的。socks5服务器可以决定是否需要认证，如果不需要认证，那么认证阶段会被直接略过。 如果需要认证，客户端向socks5服务器发起一个认证请求，包括：版本， 用户名长度，对应用户名的字节数据，密码长度，密码对应的数据。 socks5服务器收到客户端的认证请求后，解析内容，验证信息是否合法，然后给客户端响应结果，包括：版本，状态，如果STATUS字段为0x00表示认证成功，其他的值为认证失败。当客户端收到认证失败的响应后，它将会断开连接。 请求阶段： 认证通过以后，浏览器会向socks5服务器发起请求，主要信息包括版本号，请求的类型，主要是connection请求，代表代理服务器要和某个域名或某个IP地址某个端口建立TCP连接，代理服务器收到响应后，会真正和后端服务器建立连接，返回一个响应； relay阶段： 浏览器正常发送请求，代理服务器收到请求，将请求转换到真正的服务器，真的服务器返回响应，也会给代理服务器转发给浏览器，代理服务器不关心流量的细节，可以是HTTP流量，也可以是TCP流量，这就socks5的工作原理。 需求：启动程序后，通过浏览器配置代理，代理服务器的日志会打印出你访问的网站的域名或者IP，也就是你的网络流量都会经过这个代理服务器。 分析： tcp echo server 服务端监听你的信息并将其打印。 auth 浏览器会给代理服务器发送一个包，包括三个字段version，methods，methods的编码，代理服务器需要返回一个response，包括两个字段version，method。 request 读取携带的URL或IP+端口的包，并把它打印。 请求包，包括6个字段，version，command，RSV，atype，addr，port。 relay 用net.dial建立一个TCP连接，并启动两个goroutine，通过io.copy建立浏览器和下游服务器的双向数据转发。 需要使用context机制，等待ctx.Done()避免connect函数立刻返回，连接关闭。 通过switchOmega插件，实现网络流量代理，完整源码： ","date":"2022-05-12","objectID":"/2022/05/go-basic-syntax/:1:4","tags":["go基础"],"title":"Golang基础语法","uri":"/2022/05/go-basic-syntax/"},{"categories":["golang"],"content":"总结 本篇主要对Golang基础的重点易错点，几个常用标准库的使用方法进行了总结记录，并且通过两个小项目对Go语言上手实践，新手丝滑入门Golang。 第一篇blog，大纲目录比较乱，总是修修改改，后边找个时间整理一下写blog的过程（挖坑）。欢迎大家评论转载，多多发表自己的意见或建议。 （ps：blog写得真慢，要搞快点！！！） ","date":"2022-05-12","objectID":"/2022/05/go-basic-syntax/:1:5","tags":["go基础"],"title":"Golang基础语法","uri":"/2022/05/go-basic-syntax/"},{"categories":["golang"],"content":"引用参考 Go by Example 中文版 Golang标准库文档 ","date":"2022-05-12","objectID":"/2022/05/go-basic-syntax/:1:6","tags":["go基础"],"title":"Golang基础语法","uri":"/2022/05/go-basic-syntax/"}]